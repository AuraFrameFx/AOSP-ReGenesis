// -------------------------------------------------------------------------
    // Additional tests auto-generated by PR helper
    // Testing library/framework: Kotlin + JUnit 5 (Jupiter)
    // -------------------------------------------------------------------------

    @Nested
    @DisplayName("Slug normalization â€“ additional cases")
    inner class SlugNormalizationAdditionalCases {

        // Local copy to keep tests pure and avoid changing production code
        /**
         * Convert a Markdown header or arbitrary text into a normalized kebab-style slug.
         *
         * The result is lowercased, has emoji/symbol characters removed, strips Markdown header markers,
         * removes nonâ€‘ASCII alphanumeric characters except spaces and hyphens, replaces runs of whitespace
         * with single hyphens, collapses consecutive hyphens, and trims leading/trailing hyphens.
         * Non-Latin input may produce an empty string.
         *
         * @param text The input header or text to normalize into a slug.
         * @return The normalized kebab-case slug (may be empty).
         */
        /**
         * Convert a Markdown header or arbitrary text to a kebab-style slug.
         *
         * Removes leading Markdown header markers, strips emoji/symbol characters, lowercases ASCII letters,
         * removes characters that are not ASCII alphanumerics, spaces, or hyphens, collapses whitespace to
         * single hyphens, collapses repeated hyphens, and trims leading/trailing hyphens.
         *
         * @param text Input header or text to normalize.
         * @return A kebab-case slug (may be empty if no ASCII alphanumerics remain).
         */
        private fun normalizeToSlug(text: String): String {
            val header = text
                .replace(Regex("^\\s*#+\\s*"), "")
                .trim()
            val noEmoji = header.replace(Regex("[\\p{So}\\p{Sk}]"), "")
            val cleaned = noEmoji
                .lowercase(Locale.ROOT)
                .replace(Regex("[^a-z0-9\\s-]"), "")
                .replace(Regex("\\s+"), "-")
                .replace(Regex("-+"), "-")
                .trim('-')
            return cleaned
        }

        @Test
        fun `underscores are removed, not converted to hyphens`() {
            assertEquals("helloworld", normalizeToSlug("## Hello_World"))
        }

        @Test
        fun `slashes are removed, spaces become hyphens`() {
            assertEquals("ab-c", normalizeToSlug("## A/B C"))
        }

        @Test
        fun `parentheses are stripped but content kept`() {
            assertEquals("hello-world-2025", normalizeToSlug("## Hello (World) 2025"))
        }

        @Test
        fun `non latin only results in empty slug`() {
            assertEquals("", normalizeToSlug("## ÐŸÑ€Ð¸Ð¼ÐµÑ€"))
        }

        @Test
        fun `trims leading and trailing hyphens after cleanup`() {
            assertEquals("roadmap-q4", normalizeToSlug("## -- Roadmap â€” Q4 --"))
        }
    }

    @Nested
    @DisplayName("Internal anchors â€“ formatting")
    inner class InternalAnchorsFormatting {

        /**
         * Verifies that all internal Markdown anchors (links of the form `[text](#target)`) in the README use kebab-case.
         *
         * Code fences are removed before scanning to avoid matching anchors inside fenced code blocks.
         * If no anchors are found the test exits early (passes).
         */
        @Test
        fun `anchors follow kebab-case pattern`() {
            val withoutFences = readme.replace(Regex("```[\\s\\S]*?```", RegexOption.MULTILINE), "")
            val anchorRegex = Regex("\\[[^\\]]+\\]\\(#([^)]+)\\)")
            val anchors = anchorRegex.findAll(withoutFences).map { it.groupValues[1].trim() }.toList()
            if (anchors.isEmpty()) return
            val bad = anchors.filterNot { it.matches(Regex("^[a-z0-9]+(?:-[a-z0-9]+)*$")) }
            assertTrue(bad.isEmpty(), "Anchor(s) not in kebab-case: $bad")
        }
    }

    @Nested
    @DisplayName("Images and links â€“ protocol hygiene")
    inner class ImagesAndLinksMore {

        @Test
        fun `remote images use HTTPS except for local dev`() {
            val imageRegex = Regex("!\\[(.*?)\\]\\(([^)]+)\\)")
            val matches = imageRegex.findAll(readme).toList()
            val httpImages = matches.map { it.groupValues[2].trim() }
                .filter { it.startsWith("http://") }
            val allowedPrefixes = listOf(
                "http://localhost",
                "http://127.0.0.1",
                "http://0.0.0.0",
                "http://[::1]",
                "http://example.com",
                "http://www.example.com"
            )
            val insecure = httpImages.filter { url -> allowedPrefixes.none { url.startsWith(it) } }
            assertTrue(insecure.isEmpty(), "Use HTTPS for remote images where possible: $insecure")
        }
    }

    @Nested
    @DisplayName("Table of Contents â€“ presence check")
    inner class TableOfContentsPresence {

        @Test
        fun `README contains exactly one ToC section`() {
            val count = lines.count { it.trim().matches(Regex("^##\\s*ðŸ“‹\\s*Table of Contents\\s*$")) }
            assertEquals(1, count, "Expected exactly one '## ðŸ“‹ Table of Contents' section")
        }
    }

    @Nested
    @DisplayName("Build tooling and licensing â€“ extended")
    inner class BuildAndLicenseExtended {

        @Test
        fun `maven wrapper files exist when referenced by README`() {
            if (readme.contains("mvnw")) {
                assertAll(
                    { assertTrue(Files.exists(Path.of("mvnw")), "Missing mvnw script") },
                    { assertTrue(Files.exists(Path.of("mvnw.cmd")), "Missing mvnw.cmd script") }
                )
            }
        }

        /**
         * Verifies that when the README includes the Apache 2.0 shields.io badge, the repository's LICENSE
         * file exists and contains an indication of the Apache License 2.0.
         *
         * If the README does not contain the Apache-2.0 badge, the test performs no checks.
         */
        @Test
        fun `apache 2 license badge matches LICENSE content`() {
            if (readme.contains("img.shields.io/badge/License-Apache-2.0")) {
                val licensePath = Path.of("LICENSE")
                assertTrue(Files.exists(licensePath), "LICENSE file missing despite Apache-2.0 badge")
                val license = Files.readString(licensePath, StandardCharsets.UTF_8)
                val ok = license.contains("Apache License", ignoreCase = true) ||
                    license.contains("Apache 2", ignoreCase = true) ||
                    license.contains("Apache License, Version 2.0", ignoreCase = true)
                assertTrue(ok, "LICENSE should mention Apache 2.0 to align with badge")
            }
        }

        /**
         * Verifies the README contains a "## Contributing" section when a CONTRIBUTING file is present.
         *
         * Checks for any of these paths: "CONTRIBUTING.md", "Contributing.md", or "docs/CONTRIBUTING.md".
         * If one is found, asserts that the README lines include a case-insensitive "## Contributing" header.
         * The header may be optionally prefixed by a single symbol/emoji.
         */
        @Test
        fun `contributing section present when CONTRIBUTING file exists`() {
            val candidates = listOf("CONTRIBUTING.md", "Contributing.md", "docs/CONTRIBUTING.md")
            val path = candidates.map { Path.of(it) }.firstOrNull { Files.exists(it) }
            if (path != null) {
                val hasSection = lines.any {
                    it.trim().matches(Regex("^##\\s*(?:[\\p{So}\\p{Sk}]\\s*)?Contributing\\s*$", RegexOption.IGNORE_CASE))
                }
                assertTrue(hasSection, "Expected a '## Contributing' section in README when CONTRIBUTING.md exists")
            }
        }
    }