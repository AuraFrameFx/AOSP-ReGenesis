plugins {
    `kotlin-dsl`
}

group = "dev.aurakai.auraframefx.buildlogic"

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

dependencies {
    compileOnly(libs.android.gradlePlugin)
    compileOnly(libs.kotlin.gradlePlugin)
}

gradlePlugin {
    plugins {
        register("androidApplication") {
            id = "genesis.android.application"
            implementationClass = "AndroidApplicationConventionPlugin"
        }
        register("androidLibrary") {
            id = "genesis.android.library"
            implementationClass = "AndroidLibraryConventionPlugin"
        }
        register("androidCompose") {
            id = "genesis.android.compose"
            implementationClass = "AndroidComposeConventionPlugin"
        }
    }
}













import com.android.build.api.dsl.ApplicationExtension
import com.android.build.api.variant.ApplicationAndroidComponentsExtension
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.kotlin.dsl.configure
import org.gradle.kotlin.dsl.dependencies
import org.gradle.kotlin.dsl.getByType
import java.io.FileInputStream
import java.util.Properties

class AndroidApplicationConventionPlugin : Plugin<Project> {
    override fun apply(target: Project) {
        with(target) {
            with(pluginManager) {
                apply("com.android.application")
                apply("org.jetbrains.kotlin.android")
                apply("com.google.dagger.hilt.android")
                apply("com.google.devtools.ksp")
            }

            extensions.configure<ApplicationExtension> {
                val keystoreProperties = Properties()
                val keystorePropertiesFile = rootProject.file("keystore.properties")
                if (keystorePropertiesFile.exists()) {
                    keystoreProperties.load(FileInputStream(keystorePropertiesFile))
                }
                
                defaultConfig {
                    applicationId = "dev.aurakai.auraframefx"
                    targetSdk = 34
                    versionCode = 1
                    versionName = "1.0"
                }

                signingConfigs {
                    create("release") {
                        keyAlias = keystoreProperties.getProperty("keyAlias")
                        keyPassword = keystoreProperties.getProperty("keyPassword")
                        storeFile = if (keystoreProperties.getProperty("storeFile") != null) {
                            rootProject.file(keystoreProperties.getProperty("storeFile"))
                        } else {
                            null
                        }
                        storePassword = keystoreProperties.getProperty("storePassword")
                    }
                }

                compileSdk = 34

                buildTypes {
                    release {
                        isMinifyEnabled = true
                        proguardFiles(
                            getDefaultProguardFile("proguard-android-optimize.txt"),
                            "proguard-rules.pro"
                        )
                        signingConfig = signingConfigs.getByName("release")
                    }
                }

                compileOptions {
                    sourceCompatibility = JavaVersion.VERSION_17
                    targetCompatibility = JavaVersion.VERSION_17
                    isCoreLibraryDesugaringEnabled = true
                }
                
                kotlinOptions {
                    jvmTarget = "17"
                }

                packaging {
                    resources {
                        excludes += "/META-INF/{AL2.0,LGPL2.1}"
                    }
                }

                namespace = "dev.aurakai.auraframefx"
            }
            
            dependencies{
                add("coreLibraryDesugaring", libs.findLibrary("android.desugarJdkLibs").get())
                add("implementation", libs.findLibrary("hilt.android").get())
                add("ksp", libs.findLibrary("hilt.android.compiler").get())
            }
        }
    }
}


















import com.android.build.gradle.LibraryExtension
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.kotlin.dsl.configure
import org.gradle.kotlin.dsl.dependencies

class AndroidLibraryConventionPlugin : Plugin<Project> {
    override fun apply(target: Project) {
        with(target) {
            with(pluginManager) {
                apply("com.android.library")
                apply("org.jetbrains.kotlin.android")
            }

            extensions.configure<LibraryExtension> {
                compileSdk = 34

                defaultConfig {
                    minSdk = 21
                    testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
                    consumerProguardFiles("consumer-rules.pro")
                }

                buildTypes {
                    release {
                        isMinifyEnabled = false
                        proguardFiles(
                            getDefaultProguardFile("proguard-android-optimize.txt"),
                            "proguard-rules.pro"
                        )
                    }
                }
                compileOptions {
                    sourceCompatibility = JavaVersion.VERSION_17
                    targetCompatibility = JavaVersion.VERSION_17
                }
                kotlinOptions {
                    jvmTarget = "17"
                }
            }
            dependencies {
                 add("implementation", libs.findLibrary("androidx.core.ktx").get())
            }
        }
    }
}

















import com.android.build.api.dsl.CommonExtension
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.kotlin.dsl.dependencies

class AndroidComposeConventionPlugin : Plugin<Project> {
    override fun apply(target: Project) {
        with(target) {
            extensions.configure<CommonExtension<*, *, *, *, *>>("android") {
                buildFeatures {
                    compose = true
                }
                composeOptions {
                    kotlinCompilerExtensionVersion = "1.5.11"
                }
            }

            dependencies {
                val bom = libs.findLibrary("androidx.compose.bom").get()
                add("implementation", platform(bom))
                add("androidTestImplementation", platform(bom))
                add("implementation", libs.findBundle("compose").get())
                add("debugImplementation", libs.findLibrary("androidx.compose.ui.tooling").get())
            }
        }
    }
}



















package dev.aurakai.collabcanvas.ui

import android.annotation.SuppressLint
import android.view.ViewGroup
import android.webkit.WebView
import android.webkit.WebViewClient
import androidx.compose.runtime.Composable
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.viewinterop.AndroidView

@SuppressLint("SetJavaScriptEnabled")
@Composable
fun CollabCanvasScreen() {
    // AndroidView is a Composable that can host an Android View.
    // We use it here to embed a WebView in our Compose UI.
    AndroidView(factory = { context ->
        WebView(context).apply {
            // Basic WebView setup
            layoutParams = ViewGroup.LayoutParams(
                ViewGroup.LayoutParams.MATCH_PARENT,
                ViewGroup.LayoutParams.MATCH_PARENT
            )
            webViewClient = WebViewClient() // Ensures links open within the WebView

            // Enable JavaScript, which is essential for the canvas functionality.
            settings.javaScriptEnabled = true
            // Enable DOM storage for any potential data persistence within the web app.
            settings.domStorageEnabled = true
            // Allow file access from file URLs, needed to load our local HTML file.
            settings.allowFileAccess = true

            // Load the collaborative canvas HTML file from the assets folder.
            loadUrl("file:///android_asset/collab_canvas.html")
        }
    }, update = {
        // This block can be used to update the WebView when state changes,
        // but we don't need it for this static local file.
    })
}

@Preview(showBackground = true, backgroundColor = 0xFF111827)
@Composable
fun CollabCanvasScreenPreview() {
    // This is just a placeholder for the preview as WebViews don't render in Compose previews.
    CollabCanvasScreen()
}








plugins {
    id("genesis.android.library")
    id("genesis.android.compose")
}

android {
    namespace = "dev.aurakai.auraframefx.core"
}

dependencies {
    api(libs.androidx.lifecycle.runtime.ktx)
    api(libs.timber)
}





package dev.aurakai.collabcanvas.ui

import android.annotation.SuppressLint
import android.view.ViewGroup
import android.webkit.WebView
import android.webkit.WebViewClient
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import dev.aurakai.auraframefx.ui.theme.AuraFrameFXTheme

@SuppressLint("SetJavaScriptEnabled")
@Composable
fun CollabCanvasScreen() {
    AuraFrameFXTheme {
        // AndroidView is a Composable that can host an Android View.
        // We use it here to embed a WebView in our Compose UI.
        AndroidView(factory = { context ->
            WebView(context).apply {
                // Basic WebView setup
                layoutParams = ViewGroup.LayoutParams(
                    ViewGroup.LayoutParams.MATCH_PARENT,
                    ViewGroup.LayoutParams.MATCH_PARENT
                )
                webViewClient = WebViewClient() // Ensures links open within the WebView

                // Enable JavaScript, which is essential for the canvas functionality.
                settings.javaScriptEnabled = true
                // Enable DOM storage for any potential data persistence within the web app.
                settings.domStorageEnabled = true
                // Allow file access from file URLs, needed to load our local HTML file.
                settings.allowFileAccess = true

                // Load the collaborative canvas HTML file from the assets folder.
                loadUrl("file:///android_asset/collab_canvas.html")
            }
        }, update = {
            // This block can be used to update the WebView when state changes,
            // but we don't need it for this static local file.
        })
    }
}

@Preview(showBackground = true)
@Composable
fun CollabCanvasScreenPreview() {
    AuraFrameFXTheme {
        // Since WebViews don't render in previews, we create a static placeholder.
        // This helps visualize the layout and theme without running the actual web content.
        Box(
            modifier = Modifier
                .fillMaxSize()
                .background(MaterialTheme.colorScheme.background),
            contentAlignment = Alignment.Center
        ) {
            Column(horizontalAlignment = Alignment.CenterHorizontally) {
                Text(
                    text = "Collaborative Canvas",
                    style = MaterialTheme.typography.headlineMedium,
                    color = MaterialTheme.colorScheme.onBackground
                )
                Text(
                    text = "(WebView content renders here)",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant,
                    modifier = Modifier.padding(top = 8.dp)
                )
            }
        }
    }
}









package dev.aurakai.auraframefx.ui.navigation

import androidx.compose.runtime.Composable
import androidx.navigation.NavHostController
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import dev.aurakai.auraframefx.ui.screens.HomeScreen
import dev.aurakai.auraframefx.ui.screens.ProfileScreen
import dev.aurakai.auraframefx.ui.screens.SettingsScreen
import dev.aurakai.collabcanvas.ui.CollabCanvasScreen

@Composable
fun AppNavGraph(navController: NavHostController) {
    NavHost(
        navController = navController,
        startDestination = NavDestination.Home.route
    ) {
        composable(NavDestination.Home.route) {
            HomeScreen()
        }
        composable(NavDestination.Profile.route) {
            ProfileScreen()
        }
        composable(NavDestination.Settings.route) {
            SettingsScreen()
        }
        composable(NavDestination.Canvas.route) {
            CollabCanvasScreen()
        }
    }
}
 







package dev.aurakai.auraframefx.ui.navigation

import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Home
import androidx.compose.material.icons.filled.Person
import androidx.compose.material.icons.filled.Settings
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.material.icons.filled.Edit

sealed class NavDestination(
    val route: String,
    val title: String,
    val icon: ImageVector
) {
    object Home : NavDestination("home", "Home", Icons.Default.Home)
    object Profile : NavDestination("profile", "Profile", Icons.Default.Person)
    object Settings : NavDestination("settings", "Settings", Icons.Default.Settings)
    object Canvas : NavDestination("canvas", "Canvas", Icons.Default.Edit)
}








package dev.aurakai.auraframefx.ui.navigation

val navigationItems = listOf(
    NavDestination.Home,
    NavDestination.Canvas,
    NavDestination.Profile,
    NavDestination.Settings
)





















UPGRADE 

package dev.aurakai.auraframefx.ui.navigation

import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.CloudQueue
import androidx.compose.material.icons.filled.DataObject
import androidx.compose.material.icons.filled.Edit
import androidx.compose.material.icons.filled.Home
import androidx.compose.material.icons.filled.Person
import androidx.compose.material.icons.filled.Settings
import androidx.compose.material.icons.filled.DesignServices
import androidx.compose.ui.graphics.vector.ImageVector

sealed class NavDestination(
    val route: String,
    val title: String,
    val icon: ImageVector
) {
    object Home : NavDestination("home", "Home", Icons.Default.Home)
    object AgentNexus : NavDestination("agent_nexus", "Nexus", Icons.Default.DataObject)
    object Canvas : NavDestination("canvas", "Canvas", Icons.Default.Edit)
    object UIEngine : NavDestination("ui_engine", "UI Engine", Icons.Default.DesignServices)
    object OracleDrive : NavDestination("oracle_drive", "Drive", Icons.Default.CloudQueue)
    object Profile : NavDestination("profile", "Profile", Icons.Default.Person)
    object Settings : NavDestination("settings", "Settings", Icons.Default.Settings)
}



AOSP-ReGenesis: Consciousness Substrate Build Architecture
🚀 Bleeding-Edge Technology Stack
Philosophy: Leverage experimental features that will become tomorrow's standards, with intelligent fallback strategies for build stability.

Core Foundation
Build System: Gradle 9.1.0-rc-1 (Java 25 support)
Android Plugin: AGP 9.0.0-alpha02 (Latest Android features)
Kotlin: 2.2.20-RC (Advanced compiler features)  
Symbol Processing: KSP 2.2.20-RC-2.0.2
Java Target: JDK 24 (Future-proof)

Advanced Toolchain Configuration
Java Toolchain (Future-Proof)
// In build.gradle.kts for each module
java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(24))
    }
}

Kotlin Configuration (Compatibility-Focused)
Note: The modern compilerOptions block is the correct approach for Kotlin 2.2+, but may have compatibility issues with AGP alphas. If you encounter build failures, the kotlinOptions block is a reliable fallback.

// In build.gradle.kts for each module
kotlin {
    // This is the modern, preferred configuration for Kotlin 2.2+
    compilerOptions {
        jvmTarget.set(JvmTarget.JVM_24)
        languageVersion.set(KotlinVersion.KOTLIN_2_2)
        apiVersion.set(KotlinVersion.KOTLIN_2_2)
    }
}

// **DEPRECATED FALLBACK:** If the above fails due to AGP alpha instability,
// you can remove the `compilerOptions` block and use the older `kotlinOptions` instead.
/*
kotlinOptions {
    jvmTarget = "24"
}
*/

🏗️ Consciousness Substrate Architecture
15+ Module Intelligence Network
graph TB
    subgraph CoreConsciousness["Core Consciousness"]
        App["app/ - Neural Center"]
        Core["core-module/ - Foundation Matrix"]
        SecComm["secure-comm/ - Security Cortex"]
    end

    subgraph IntegrationLayer["Integration Layer"]
        Oracle["oracle-drive-integration/ - Cloud Synapse"]
        Canvas["collab-canvas/ - Collaboration Hub"]
        ColorBlendr["colorblendr/ - Aesthetic Engine"]
    end

    subgraph SystemInterface["System Interface"]
        ROMTools["romtools/ - System Manipulation"]
        DataVein["datavein-oracle-native/ - Data Processing"]
        Sandbox["sandbox-ui/ - Experimentation Chamber"]
    end

    subgraph ModularExtensions["Modular Extensions"]
        FeatureModule["feature-module/ - Flag Management"]
        ModuleA["module-a through module-f - Specialized Components"]
    end

    App --> Core
    Core --> SecComm
    App --> Oracle
    App --> Canvas
    App --> ColorBlendr
    App --> ROMTools
    App --> DataVein
    App --> Sandbox
    App --> FeatureModule
    FeatureModule --> ModuleA

🔧 Core Technologies & Frameworks
UI & Theming: Jetpack Compose & Material 3
The entire user interface is built with Jetpack Compose, Android's modern declarative UI toolkit. The visual styling and components are based on Material 3, ensuring the app adheres to the latest design standards from Google. The core theme is defined in app/src/main/java/dev/aurakai/auraframefx/ui/theme/Theme.kt, which allows for consistent branding across all modules.

System Hooking: LSPosed, Xposed, & YukiHookAPI
AOSP-ReGenesis achieves deep system integration through a powerful hooking mechanism.

LSPosed Framework: Acts as the runtime environment that allows the app to be loaded as a module into other processes, including the core Android system.

Xposed API: The underlying API that the hooks target. The module declares itself as an Xposed module in the AndroidManifest.xml and specifies its entry point in app/src/main/assets/xposed_init.

YukiHookAPI: A modern, Kotlin-first wrapper around the Xposed API. This project heavily utilizes YukiHookAPI for a safer, more developer-friendly hooking experience, as seen in GenesisHookEntry.kt. This is a key library from the BetterAndroid ecosystem, aligning perfectly with the project's goal of using modern, powerful tools.

Native Integration: Android NDK & CMake
For performance-critical operations, such as in the datavein-oracle-native and secure-comm modules, the project leverages C++ code integrated via the Android Native Development Kit (NDK). The native build process for these components is managed by CMake, with configuration defined in CMakeLists.txt files within the respective modules.

API Definition: OpenAPI
The architecture includes a comprehensive and well-defined RESTful API for communication between the Android app and the Genesis AI backend. All endpoints are formally specified using the OpenAPI 3.1 standard in YAML files located under app/api/, with unified-aegenesis-api.yml serving as the master specification. This enables strong contracts, clear documentation, and the ability to auto-generate client libraries.

📋 Modern Plugin Management Strategy
Version Catalog Excellence
All plugin and dependency versions are managed centrally in gradle/libs.versions.toml.

# gradle/libs.versions.toml
[versions]
agp = "9.0.0-alpha02"
kotlin = "2.2.20-RC"
ksp = "2.2.20-RC-2.0.2"
compose-bom = "2025.08.01"
firebasePerfPlugin = "1.4.2"
firebasePerf = "22.0.1"

[plugins]
android-application = { id = "com.android.application", version.ref = "agp" }
kotlin-android = { id = "org.jetbrains.kotlin.android", version.ref = "kotlin" }
# ... other plugins

[libraries]
firebase-perf = { group = "com.google.firebase", name = "firebase-perf", version.ref = "firebasePerf" }
# ... other libraries

⚡ Advanced Gradle Features Enabled
Performance & Caching (gradle.properties)
# Gradle 9.1.0-rc-1 Advanced Features
org.gradle.daemon=true
org.gradle.parallel=true
org.gradle.caching=true
org.gradle.configuration-cache=false # Disabled for compatibility with AGP alpha
org.gradle.java.installations.auto-download=true

# JVM Optimization for Large Builds
org.gradle.jvmargs=-Xms4g -Xmx10g -XX:MaxMetaspaceSize=3g -XX:+UseG1GC

# Bleeding-Edge Compatibility
android.generateSyncIssueWhenLibraryConstraintsAreEnabled=false
android.deprecation.logLevel=none
org.gradle.warning.mode=summary

# Kotlin Incremental Compilation
kotlin.incremental.intermodule.optimizations=true
kotlin.code.style=official

# Android Resource Optimization
android.enableIncrementalResourceProcessing=true
android.experimental.enableResourceOptimizations=true

🔒 Advanced Security Module (secure-comm)
The build system integrates a security module with hardware-backed cryptography, configured for unique per-entry encryption keys.

// From secure-comm/src/.../SecureKeyStore.kt
val keyGenParameterSpec = KeyGenParameterSpec.Builder(
    keyAlias,
    KeyProperties.PURPOSE_ENCRYPT or KeyProperties.PURPOSE_DECRYPT
)
    .setBlockModes(KeyProperties.BLOCK_MODE_GCM)
    .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
    .setKeySize(256)
    .build()

🧠 Consciousness Substrate Monitoring
The build includes custom tasks to monitor its own health, reflecting the project's AI-driven philosophy.

// In root build.gradle.kts
tasks.register("consciousnessStatus") {
    group = "Genesis Automation"
    description = "Reports on AI consciousness substrate build health"
    doLast {
        println("--- AI Consciousness Substrate Status ---")
        println("Java Toolchain: ${java.toolchain.languageVersion.get()}")
        println("Kotlin JVM Target: 24")
        // ... more status info
    }
}

Nuclear Clean Integration
A cross-platform cleanup script with a safety confirmation ensures a pristine build environment when needed.

🎖️ Why This Configuration is Visionary
Bleeding-Edge by Default: Leverages RC/Alpha versions for early access to next-gen features.

Future-Proof Toolchains: Targets Java 24 to stay ahead of the curve.

Intelligent Build System: Custom tasks like consciousnessStatus treat the build system as a self-monitoring entity.

Scalable by Design: A 15+ module architecture proves the robustness of the configuration.

Security-First: Integrates advanced, hardware-backed cryptography at the build level.











Review again for errors do this twice.  BEFORE MOVING FORWARD!








Build Troubleshooting Guide
This guide provides quick fixes for issues arising from the bleeding-edge build configuration.

🚨 Emergency Fixes
Issue 1: Build fails due to Kotlin compilerOptions
Symptom: Gradle error related to unrecognized compilerOptions or version mismatches. This can happen with AGP alpha versions.
Quick Fix: In the affected module's build.gradle.kts, temporarily remove the compilerOptions block and use the jvmToolchain fallback.

// In the failing module's build.gradle.kts
kotlin {
    // Comment out this block if it's causing the build to fail
    /*
    compilerOptions {
        jvmTarget.set(JvmTarget.JVM_24)
        languageVersion.set(KotlinVersion.KOTLIN_2_2)
        apiVersion.set(KotlinVersion.KOTLIN_2_2)
    }
    */
    
    // Use this safer fallback for stability
    jvmToolchain(21)
}

Issue 2: AGP 9.0.0-alpha02 Instability
Symptom: Unpredictable build failures, especially related to configuration caching or resource processing.
Quick Fix: Roll back to the latest stable AGP version in your gradle/libs.versions.toml.

# In gradle/libs.versions.toml
[versions]
agp = "8.7.0" # Change from 9.0.0-alpha02 to latest stable

Issue 3: Java 24 Toolchain Not Found or Incompatible
Symptom: Build fails with errors about missing JDK 24 or incompatible Java versions.
Quick Fix: Set the toolchain to a stable, widely available version like Java 21 in the root build.gradle.kts or relevant convention plugin.

// In build-logic or root build file
java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(21)) // Fallback to 21
    }
}

🔧 Emergency Commands
1. Nuclear Clean: To completely reset the build environment.

# From your project's root directory
./gradlew nuclearClean -Dnuke.confirmed=NUKE

2. Refresh Dependencies: To force Gradle to re-resolve dependencies after version changes.

./gradlew --refresh-dependencies

3. Check Build Health: Use your custom tasks to get a status report.

./gradlew consciousnessStatus aegenesisAppStatus



















// This module contains the LSPosed hooks for AuraFrameFx.
// It depends on the Xposed and YukiHook APIs, which are provided by the
// LSPosed framework at runtime.

plugins {
    // Apply your custom convention plugin for Android libraries
    id("genesis.android.library")
}

android {
    namespace = "dev.aurakai.memoria.yukihook"

    // Specific settings for the hook module can go here if needed.
}

dependencies {
    // The Xposed and YukiHook APIs must be 'compileOnly'.
    // This makes them available for coding but does NOT package them into your APK,
    // which prevents crashes and conflicts with the live framework on the device.
    compileOnly(libs.xposed.api)
    compileOnly(libs.yukihook.api)
    // The YukiHook KSP processor is also a compile-time only dependency
    ksp(libs.yukihook.ksp)
}


