// -------------------------------------------------------------------------
    // Additional tests auto-generated by PR helper
    // Testing library/framework: Kotlin + JUnit 5 (Jupiter)
    // -------------------------------------------------------------------------

    @Nested
    @DisplayName("Slug normalization â€“ additional cases")
    inner class SlugNormalizationAdditionalCases {

        // Local copy to keep tests pure and avoid changing production code
        /**
         * Convert an input heading or text into a kebab-style URL slug.
         *
         * Removes leading Markdown header markers (e.g. leading `#`), strips emoji and symbol characters,
         * lowercases ASCII letters, removes any characters except `a-z`, `0-9`, spaces and hyphens,
         * replaces runs of whitespace with single hyphens, collapses consecutive hyphens, and trims
         * leading/trailing hyphens. Non-Latin letters are removed by the character-class filter; the
         * result may be an empty string if no allowed characters remain.
         *
         * @param text Input text or heading to normalize into a slug.
         * @return The normalized slug (may be empty).
         */
        private fun normalizeToSlug(text: String): String {
            val header = text
                .replace(Regex("^\\s*#+\\s*"), "")
                .trim()
            val noEmoji = header.replace(Regex("[\\p{So}\\p{Sk}]"), "")
            val cleaned = noEmoji
                .lowercase(Locale.ROOT)
                .replace(Regex("[^a-z0-9\\s-]"), "")
                .replace(Regex("\\s+"), "-")
                .replace(Regex("-+"), "-")
                .trim('-')
            return cleaned
        }

        @Test
        fun `underscores are removed, not converted to hyphens`() {
            assertEquals("helloworld", normalizeToSlug("## Hello_World"))
        }

        @Test
        fun `slashes are removed, spaces become hyphens`() {
            assertEquals("ab-c", normalizeToSlug("## A/B C"))
        }

        @Test
        fun `parentheses are stripped but content kept`() {
            assertEquals("hello-world-2025", normalizeToSlug("## Hello (World) 2025"))
        }

        @Test
        fun `non latin only results in empty slug`() {
            assertEquals("", normalizeToSlug("## ÐŸÑ€Ð¸Ð¼ÐµÑ€"))
        }

        @Test
        fun `trims leading and trailing hyphens after cleanup`() {
            assertEquals("roadmap-q4", normalizeToSlug("## -- Roadmap â€” Q4 --"))
        }
    }

    @Nested
    @DisplayName("Internal anchors â€“ formatting")
    inner class InternalAnchorsFormatting {

        @Test
        fun `anchors follow kebab-case pattern`() {
            val withoutFences = readme.replace(Regex("```[\\s\\S]*?```", RegexOption.MULTILINE), "")
            val anchorRegex = Regex("\\[[^\\]]+\\]\\(#([^)]+)\\)")
            val anchors = anchorRegex.findAll(withoutFences).map { it.groupValues[1].trim() }.toList()
            if (anchors.isEmpty()) return
            val bad = anchors.filterNot { it.matches(Regex("^[a-z0-9]+(?:-[a-z0-9]+)*$")) }
            assertTrue(bad.isEmpty(), "Anchor(s) not in kebab-case: $bad")
        }
    }

    @Nested
    @DisplayName("Images and links â€“ protocol hygiene")
    inner class ImagesAndLinksMore {

        @Test
        fun `remote images use HTTPS except for local dev`() {
            val imageRegex = Regex("!\\[(.*?)\\]\\(([^)]+)\\)")
            val matches = imageRegex.findAll(readme).toList()
            val httpImages = matches.map { it.groupValues[2].trim() }
                .filter { it.startsWith("http://") }
            val allowedPrefixes = listOf(
                "http://localhost",
                "http://127.0.0.1",
                "http://0.0.0.0",
                "http://[::1]",
                "http://example.com",
                "http://www.example.com"
            )
            val insecure = httpImages.filter { url -> allowedPrefixes.none { url.startsWith(it) } }
            assertTrue(insecure.isEmpty(), "Use HTTPS for remote images where possible: $insecure")
        }
    }

    @Nested
    @DisplayName("Table of Contents â€“ presence check")
    inner class TableOfContentsPresence {

        @Test
        fun `README contains exactly one ToC section`() {
            val count = lines.count { it.trim().matches(Regex("^##\\s*ðŸ“‹\\s*Table of Contents\\s*$")) }
            assertEquals(1, count, "Expected exactly one '## ðŸ“‹ Table of Contents' section")
        }
    }

    @Nested
    @DisplayName("Build tooling and licensing â€“ extended")
    inner class BuildAndLicenseExtended {

        /**
         * Asserts that the Maven wrapper scripts are present when the README references `mvnw`.
         *
         * If the README contains the substring "mvnw", this test checks that both `mvnw` and
         * `mvnw.cmd` exist in the repository; otherwise the test is skipped.
         */
        @Test
        fun `maven wrapper files exist when referenced by README`() {
            if (readme.contains("mvnw")) {
                assertAll(
                    { assertTrue(Files.exists(Path.of("mvnw")), "Missing mvnw script") },
                    { assertTrue(Files.exists(Path.of("mvnw.cmd")), "Missing mvnw.cmd script") }
                )
            }
        }

        @Test
        fun `apache 2 license badge matches LICENSE content`() {
            if (readme.contains("img.shields.io/badge/License-Apache-2.0")) {
                val licensePath = Path.of("LICENSE")
                assertTrue(Files.exists(licensePath), "LICENSE file missing despite Apache-2.0 badge")
                val license = Files.readString(licensePath, StandardCharsets.UTF_8)
                val ok = license.contains("Apache License", ignoreCase = true) ||
                    license.contains("Apache 2", ignoreCase = true) ||
                    license.contains("Apache License, Version 2.0", ignoreCase = true)
                assertTrue(ok, "LICENSE should mention Apache 2.0 to align with badge")
            }
        }

        @Test
        fun `contributing section present when CONTRIBUTING file exists`() {
            val candidates = listOf("CONTRIBUTING.md", "Contributing.md", "docs/CONTRIBUTING.md")
            val path = candidates.map { Path.of(it) }.firstOrNull { Files.exists(it) }
            if (path != null) {
                val hasSection = lines.any {
                    it.trim().matches(Regex("^##\\s*(?:[\\p{So}\\p{Sk}]\\s*)?Contributing\\s*$", RegexOption.IGNORE_CASE))
                }
                assertTrue(hasSection, "Expected a '## Contributing' section in README when CONTRIBUTING.md exists")
            }
        }
    }